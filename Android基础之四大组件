Android基础篇

1、Android支持的五种基本布局：

LinearLayout、RelativeLayout 、FrameLayout、TableLayout、AbsoluteLayout 都是viewGroup的子类。

2、Activity生命周期：

    启动Activity: onCreate()—>onStart()—>onResume()，Activity进入运行状态。

    Activity退居后台: 当前Activity转到新的Activity界面或按Home键回到主屏： onPause()—>onStop()，进入停滞状态。

    Activity返回前台: onRestart()—>onStart()—>onResume()，再次回到运行状态。

    Activity退居后台，且系统内存不足， 系统会杀死这个后台状态的Activity（此时这个Activity引用仍然处在任务栈中，
    只是这个时候引用指向的对象已经为null），若再次回到这个Activity,则会走onCreate()–>onStart()—>onResume()
    (将重新走一次Activity的初始化生命周期)

    锁屏：onPause()->onStop()

    解锁：onStart()->onResume()

3、Activity启动方式：

android:launchMode="standard|singleInstance|singleTask|singleTop"来控制Acivity任务栈。
避免重复点击：利用singleTask启动方式
主界面启动方式：singleTop,当返回到主界面时可以直接退出。

4、界面异常退出保存状态：

当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候。 
由于onSaveInstanceState()方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态）。不应该用这个方法去存储持久化数据。
当用户离开这个activity的时候应该在onPause()方法中存储持久化数据（例如应该被存储到数据库中的数据）。

onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。

恢复出保存的状态：onRestoreInstanceState

onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可选择在onCreate方法中做数据还原。onRestoreInstanceState在onstart之后执行。

5、广播(Broadcast Receiver)的两种动态注册和静态注册有什么区别。

    静态注册：在AndroidManifest.xml文件中进行注册，当App退出后，Receiver仍然可以接收到广播并且进行相应的处理

    动态注册：在代码中动态注册，当App退出后，也就没办法再接受广播了。
    生命周期：生成 --> 注册 --> onReceive()-->取消注册.
    　一般：在onStart中注册，onStop中取消unregisterReceiver
     
6、各个组件的响应ANR:

应用在5秒内未响应用户的输入事件（如按键或者触摸）

BroadcastReceiver未在10秒内完成相关的处理

Service在特定的时间内无法处理完成 20秒
以上情况就会发生ANR异常。
7、注意点：
Activity的onCreate和onResume回调中尽量避免耗时的代码

BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。
8、如何保证service在后台不被Kill？
一、onStartCommand方法，返回START_STICKY

    START_STICKY 在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。
    不久后service就会再次尝试重新创建，因为保留在开始状态，在创建service后将保证调用onstartCommand。
    如果没有传递任何开始命令给service，那将获取到null的intent。

    START_NOT_STICKY 在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。
    Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，
    也就是期间onstartCommand不会接收到任何null的intent。

    START_REDELIVER_INTENT 在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。
    直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。
    因此onstartCommand不会接收到任何null的intent。

二、提升service优先级

在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = "1000"这个属性设置最高优先级，1000是最高值，
如果数字越小则优先级越低，同时适用于广播。但是该方法并不能保证service一定会不被杀死，只是降低了service被杀死的几率。
三、提升service进程优先级

Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:

    前台进程( FOREGROUND_APP)
    可视进程(VISIBLE_APP )
    次要服务进程(SECONDARY_SERVER )
    后台进程 (HIDDEN_APP)
    内容供应节点(CONTENT_PROVIDER)
    空进程(EMPTY_APP)
因此，前台进程是最不容易被杀死的。空进程当Java虚拟机回收内存时会回收。

四、onDestroy方法里重启service
根据service的生命周期，在service销毁过程中，正常情况下肯定会经历Destroy生命周期，因此该方法会使得当destroy的时候重启service服务。
可在ondestroy方法中发送一个广播，然后在接受广播时重启Service。




